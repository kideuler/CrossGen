// CrossGen: Mesh2D using Gmsh
// Main program: load .geo, normalize to [-1,1]^2, mesh with h=2/np, save to output dir.

#include <gmsh.h>
#include <iostream>
#include <string>
#include <vector>
#include <utility>
#include <filesystem>
#include <unordered_map>
#include <fstream>
#include <iomanip>

namespace fs = std::filesystem;

static void setUniformMeshSize(double h) {
	// Set uniform mesh size on all points in the current model
	std::vector<std::pair<int, int>> points;
	gmsh::model::getEntities(points, 0); // dim=0 for points
	if (points.empty()) {
		// If points are not yet available, synchronize geometry to create them
		try {
			gmsh::model::geo::synchronize();
		} catch (...) {
			// ignore
		}
		gmsh::model::getEntities(points, 0);
	}
	// Apply size directly to point entity tags (vectorpair expected)
	if (!points.empty()) gmsh::model::mesh::setSize(points, h);
}

static void normalizeToUnitSquare() {
	// Compute bounding box of the whole model and translate/scale to fit [-1,1]^2
	double xmin = 0, ymin = 0, zmin = 0, xmax = 0, ymax = 0, zmax = 0;
	gmsh::model::getBoundingBox(-1, -1, xmin, ymin, zmin, xmax, ymax, zmax);

	double cx = 0.5 * (xmin + xmax);
	double cy = 0.5 * (ymin + ymax);
	double width = xmax - xmin;
	double height = ymax - ymin;
	double maxDim = std::max(width, height);
	if (maxDim <= 0) return;

		// Gather all entities to transform
		std::vector<std::pair<int, int>> all;
		gmsh::model::getEntities(all);

		// Apply transforms for both geometry kernels when available
		double s = 2.0 / maxDim;
		try {
			gmsh::model::geo::translate(all, -cx, -cy, 0.0);
			gmsh::model::geo::dilate(all, 0.0, 0.0, 0.0, s, s, 1.0);
			gmsh::model::geo::synchronize();
		} catch (...) {
			// ignore if GEO kernel not in use
		}
		try {
			gmsh::model::occ::translate(all, -cx, -cy, 0.0);
			gmsh::model::occ::dilate(all, 0.0, 0.0, 0.0, s, s, 1.0);
			gmsh::model::occ::synchronize();
		} catch (...) {
			// ignore if OCC kernel not in use
		}
}

static void writeOBJ(const std::string &path) {
	// Fetch all nodes
	std::vector<std::size_t> nodeTags;
	std::vector<double> nodeCoords;
	std::vector<double> nodeParam;
	gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParam);

	// Map node tag -> 1-based OBJ index in order of writing
	std::unordered_map<std::size_t, int> idx;
	idx.reserve(nodeTags.size());
	for (std::size_t i = 0; i < nodeTags.size(); ++i) {
		idx[nodeTags[i]] = static_cast<int>(i + 1);
	}

	std::ofstream out(path);
	if (!out) {
		throw std::runtime_error("Failed to open OBJ file for writing: " + path);
	}
	out.setf(std::ios::fixed, std::ios::floatfield);
	out << std::setprecision(17);

	out << "# OBJ generated by CrossGen Mesh2Dgmsh\n";

	// Write vertices
	for (std::size_t i = 0; i < nodeTags.size(); ++i) {
		double x = nodeCoords[3 * i + 0];
		double y = nodeCoords[3 * i + 1];
		double z = nodeCoords[3 * i + 2];
		out << "v " << x << ' ' << y << ' ' << z << '\n';
	}

	// Fetch 2D elements (surfaces)
	std::vector<int> types;
	std::vector<std::vector<std::size_t>> elementTags, elementNodeTags;
	gmsh::model::mesh::getElements(types, elementTags, elementNodeTags, 2, -1);

	// Write faces: handle triangles (3-node and 6-node) and degrade quads to triangles
	for (std::size_t k = 0; k < types.size(); ++k) {
		int et = types[k];
		const auto &nodes = elementNodeTags[k];
		if (et == 2) {
			// 3-node triangles
			for (std::size_t j = 0; j + 2 < nodes.size(); j += 3) {
				int a = idx[nodes[j + 0]];
				int b = idx[nodes[j + 1]];
				int c = idx[nodes[j + 2]];
				out << "f " << a << ' ' << b << ' ' << c << '\n';
			}
		} else if (et == 9) {
			// 6-node triangles: use corner nodes (1,2,3)
			for (std::size_t j = 0; j + 5 < nodes.size(); j += 6) {
				int a = idx[nodes[j + 0]];
				int b = idx[nodes[j + 1]];
				int c = idx[nodes[j + 2]];
				out << "f " << a << ' ' << b << ' ' << c << '\n';
			}
		} else if (et == 3) {
			// 4-node quads: split into two triangles (1,2,3) and (1,3,4)
			for (std::size_t j = 0; j + 3 < nodes.size(); j += 4) {
				int n1 = idx[nodes[j + 0]];
				int n2 = idx[nodes[j + 1]];
				int n3 = idx[nodes[j + 2]];
				int n4 = idx[nodes[j + 3]];
				out << "f " << n1 << ' ' << n2 << ' ' << n3 << '\n';
				out << "f " << n1 << ' ' << n3 << ' ' << n4 << '\n';
			}
		} else {
			// Other element types are ignored for OBJ output
		}
	}

	out.close();
}

int main(int argc, char **argv) {
	if (argc < 4) {
		std::cerr << "Usage: Mesh2Dgmsh <input.geo> <output_dir> <np>\n";
		return 1;
	}

	const std::string inputGeo = argv[1];
	const std::string outputDir = argv[2];
	const int np = std::stoi(argv[3]);
	if (np <= 0) {
		std::cerr << "Error: np must be a positive integer.\n";
		return 1;
	}

	try {
		gmsh::initialize();
		gmsh::option::setNumber("General.Terminal", 1);

		// Load the .geo file as the current model
		gmsh::open(inputGeo);

		// Use GEO factory if applicable
		gmsh::model::geo::synchronize();

		// Merge geometry (if the .geo creates multiple components, open already loads them).
		// Apply normalization: translate and scale to fit within [-1,1]^2
		normalizeToUnitSquare();

		// Set characteristic length h = 2/np
		const double h = 2.0 / static_cast<double>(np);
		setUniformMeshSize(h);

		// Generate 2D mesh
		gmsh::model::mesh::generate(2);

		// Ensure output directory exists
		fs::create_directories(outputDir);

	// Compose output file path: same basename as input .geo, with .obj in outputDir
		fs::path inPath(inputGeo);
		std::string baseName = inPath.stem().string();
		fs::path outPath = fs::path(outputDir) / (baseName + ".obj");

	// Write OBJ manually from mesh data
	writeOBJ(outPath.string());

		gmsh::finalize();
	} catch (const std::exception &e) {
		std::cerr << "Gmsh error: " << e.what() << "\n";
		try { gmsh::finalize(); } catch (...) {}
		return 1;
	} catch (...) {
		std::cerr << "Unknown error during meshing.\n";
		try { gmsh::finalize(); } catch (...) {}
		return 1;
	}

	return 0;
}

